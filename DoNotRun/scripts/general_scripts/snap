#!/bin/bash
#
# snap - part of the Arch-Setup project
# Copyright (C) 2023, Scott Wyman, development@scottwyman.me
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


#
# A simple to use snapper abstraction for writing to multiple configs at once
#

get_configs() {
    CONFIGS=($(sudo snapper list-configs | awk 'NR>2 {print $1}'))

    [[ ${#CONFIGS[@]} -gt 0 ]] || {
        echo -e "\n - [ERROR] Must create a config before using snap"
        exit 3
    
    }
}

# Check that the required packages are installed
check_packages() {
    get_configs # Exits if no configs exist

    required_packages=(btrfs snapper)

    for package in ${required_packages[@]}; do 
        $package --version &>/dev/null || {
            echo -e "\n - [ERROR] $package must be installed - \n"
            missing_packages=true
        } 
    done

    [[ $missing_packages = true ]] && exit 3
}

display_help() {
    echo -e "\nUsage: snap [COMMAND]"
    echo -e "\nA package manager wrapper using btrfs snapper snapshots to"
    echo -e " have full control over the packages on your system\n"

    echo "Commands:"
    printf "\t%-15s %-1s\n" "list" "displays a list of the packages installed via snap along with there state"
    printf "\t%-15s %-1s\n" "install" "creates a pre & post snapshot of the package installation"
    printf "\t%-15s %-1s\n" "uninstall" "undoes the changes between the pre & post snapshot, and deletes the snapshots"
    printf "\t%-15s %-1s\n" "disable" "un-does the changes between the pre & post snapshots"
    printf "\t%-15s %-1s\n" "enable" "re-does the changes betweem the pre & post snapshots"
    printf "\t%-15s %-1s\n" "upgrade" "Reinstalls the newest package version, replacing the old snapshot"
    printf "\t%-15s %-1s\n" "version" "Returns version information"

    echo -e "\nCommand Flags:\n"
    echo -e "\tinstall:"
    printf "\t    %-20s\t %-1s\n" "-F | --flag" "description"
    echo -e "\tuninstall:"
    printf "\t    %-20s\t %-1s\n" "-f | --flag" "description"
    echo -e "\tenable:"
    printf "\t    %-20s\t %-1s\n" "-F | --flag" "description"

    echo -e "\nExamples:"
    echo -e "\t\`snapper list\`"
    echo -e "\t\`snapper install go rustup python\`"
    echo -e "\t\`snapper uninstall go rustup\`"
    echo -e "\t\`snapper disable go python\`"
    echo -e "\t\`snapper enable go\`"
    echo -e "\t\`snapper upgrade python\`"

    echo -e "\nError Codes:"
    printf "\t%-3s %-1s\n" "1" "Invalid command"
    printf "\t%-3s %-1s\n" "2" "Package doesn't exist"
    printf "\t%-3s %-1s\n" "3" "Missing dependencies"
}

install_packages() {
    # unset flag variables before match, for safety
    local unset noconfirm_flag \
        skipped_command_input \

    #
    # Capture flags
    #
    for arg in "${@}";
    do
        case $arg in
            "--noconfirm" | "-y")
                [[ -n "$noconfirm_flag" ]] && {
                    echo -e "\n - [ERROR] duplicated noconfirm flag - \n"
                    exit 1
                }
                local noconfirm_flag="--noconfirm"
            ;;
            *) 
                [[ "$arg" == "install" && -z "$skipped_command_input" ]] && {
                    skipped_command_input=true
                    continue
                }

                local package_names+=($arg)
            ;;
        esac
    done
    
    [[ ${#package_names[@]} -lt 0 ]] && {
        echo -e "\n - [ERROR] must provide at least one package - \n"
        exit 1
    }

    pacman -Si ${package_names[@]} &>/dev/null || {
        echo "...failed to find all packages, updating package index..."
        sudo pacman -Si ${package_names[@]} >/dev/null || exit 2
    }

    for package in ${package_names[@]}
    do
        pacman -Q $package &>/dev/null && {
            echo "$package already installed... skipping"
            continue
        }
        list_packages $package | grep "$package" &>/dev/null && {
            echo "$package snapshot already exists, try enabling instead... skipping"
            continue
        }

        for config in ${CONFIGS[@]}
        do
            sudo snapper -c $config create -d "snap__$package" -t pre
        done

        [[ -n $noconfirm_flag ]] && {
            echo -n "...installing $package..."
            sudo pacman -S $noconfirm_flag $package &>/dev/null || {
                pre_number=$(sudo snapper -c $config list | awk '{print $1}' | tail -n 1)
                sudo snapper -c $config delete $pre_number
                echo -e "\n - [ERROR] pacman failed to install $package... stopping - \n"
                exit 2
            }
            echo "[DONE]"
        } || sudo pacman -S $package || {
            pre_number=$(sudo snapper -c $config list | awk '{print $1}' | tail -n 1)
            sudo snapper -c $config delete $pre_number
            exit 2
        }

        for config in ${CONFIGS[@]}
        do
            # We can assume that the most recent snapshot was the one we created
            pre_number=$(sudo snapper -c $config list | awk '{print $1}' | tail -n 1)
            sudo snapper -c $config create -d "snap__$package" \
                -t post --pre-number $pre_number 
        done
    done
}

uninstall_packages() {
    # unset flag variables before match, for safety
    local unset skipped_command_input \
        noconfirm_flag \

    #
    # Capture flags
    #
    for arg in "${@}";
    do
        case $arg in
            "--noconfirm" | "-y")
                [[ -n "$noconfirm_flag" ]] && {
                    echo -e "\n - [ERROR] duplicated noconfirm flag - \n"
                    exit 1
                }
                local noconfirm_flag="--noconfirm"
            ;;
            *) 
                [[ "$arg" == "uninstall" && -z "$skipped_command_input" ]] && {
                    skipped_command_input=true
                    continue
                }

                local package_names+=($arg)
            ;;
        esac
    done

    [[ ${#package_names[@]} -lt 0 ]] && {
        echo -e "\n - [ERROR] must provide at least one package - \n"
        exit 1
    }

    # Uninstall to remove any files created after installation that pacman
    #  was instructed to delete
    #
    enable_packages ${package_names[@]}
    for package in ${package_names[@]}
    do
        [[ -n $noconfirm_flag ]] && {
            echo -n "...uninstalling $package..."
            sudo pacman -R $noconfirm_flag $package &>/dev/null || {
                echo -e "\n - [ERROR] pacman failed to uninstall $package... stopping - \n"
                exit 2
            }
            echo "[DONE]"
        } || {
            sudo pacman -R $package || exit 2
        }
    done
    
    disable_packages ${package_names[@]}

    for package in ${package_names[@]}
    do
        for config in ${CONFIGS[@]}
        do
            sudo snapper -c $config list | grep "snap__$package" | while IFS= read -r line   
            do
                snapshot_number=$(echo $line | awk '{print $1}')
                sudo snapper -c $config delete $snapshot_number
            done
        done
    done
}

disable_packages() {
    # unset flag variables before match, for safety
    local unset skipped_command_input

    #
    # Capture flags
    #
    for arg in "${@}";
    do
        case $arg in
            *) 
                [[ "$arg" == "disable" && -z "$skipped_command_input" ]] && {
                    skipped_command_input=true
                    continue
                }

                local package_names+=($arg)
            ;;
        esac
    done

    [[ ${#package_names[@]} -lt 0 ]] && {
        echo -e "\n - [ERROR] must provide at least one package - \n"
        exit 1
    }

    for package in ${package_names[@]}
    do
        list_packages | grep "$package" &>/dev/null || {
            echo "'$package' doesn't exist... skipping"
            continue
        }

        for config in ${CONFIGS[@]}
        do
            sudo snapper -c $config list | grep "snap__$package" | sort -n | while IFS= read -r line   
            do
                snapshot_numbers+=($(echo $line | awk '{print $1}'))
                [[ ${#snapshot_numbers[@]} == 2 && ${snapshot_numbers[0]} -lt ${snapshot_numbers[1]} ]] && {
                    sudo snapper -c $config undochange "${snapshot_numbers[0]}..${snapshot_numbers[1]}" &>/dev/null
                    snapshot_numbers=()
                }
            done
        done
    done
}

enable_packages() {
    # unset flag variables before match, for safety
    local unset skipped_command_input

    #
    # Capture flags
    #
    for arg in "${@}";
    do
        case $arg in
            *) 
                [[ "$arg" == "enable" && -z "$skipped_command_input" ]] && {
                    skipped_command_input=true
                    continue
                }

                local package_names+=($arg)
            ;;
        esac
    done

    [[ ${#package_names[@]} -lt 0 ]] && {
        echo -e "\n - [ERROR] must provide at least one package - \n"
        exit 1
    }

    for package in ${package_names[@]}
    do
        list_packages | grep "$package" &>/dev/null || {
            echo "'$package' doesn't exist... skipping"
            continue
        }

        for config in ${CONFIGS[@]}
        do
            sudo snapper -c $config list | grep "snap__$package" | sort -nr | while IFS= read -r line   
            do
                snapshot_numbers+=($(echo $line | awk '{print $1}'))
                [[ ${#snapshot_numbers[@]} == 2 && ${snapshot_numbers[0]} -gt ${snapshot_numbers[1]} ]] && {
                    sudo snapper -c $config undochange "${snapshot_numbers[0]}..${snapshot_numbers[1]}" &>/dev/null
                    snapshot_numbers=()
                }
            done
        done
    done
}

upgrade_packages() {
    # unset flag variables before match, for safety
    local unset noconfirm_flag \
        skipped_command_input \

    #
    # Capture flags
    #
    for arg in "${@}";
    do
        case $arg in
            "--noconfirm" | "-y")
                [[ -n "$noconfirm_flag" ]] && {
                    echo -e "\n - [ERROR] duplicated noconfirm flag - \n"
                    exit 1
                }
                local noconfirm_flag="--noconfirm"
            ;;
            *) 
                [[ "$arg" == "upgrade" && -z "$skipped_command_input" ]] && {
                    skipped_command_input=true
                    continue
                }

                local package_names+=($arg)
            ;;
        esac
    done



    uninstall_packages $noconfirm_flag ${package_names[@]} \
        && install_packages $noconfirm_flag ${package_names[@]}
}

list_packages() {
    # Loop over each row of the snapper list output containing "snap__"
    sudo snapper -c ${CONFIGS[0]} list | grep "snap__" | while IFS= read -r line
    do
        # Only output packages that have pre and post snapshots
        [[ "$(echo $line | awk -F '|' '{print $2}' )" == " post " ]] && {
            # Grabs the snapshot description
            package_name=$(echo $line | awk -F '|' '{print $7}' | sed 's/snap__//')
            { which $package_name || type $package_name; } &>/dev/null && {
                readarray -t package_version_array_output < <(pacman -Q $package_name)
                echo " $package_version_array_output" | tr '[:upper:]' '[:lower:]'
            } \
                || printf "%-20s %-1s\n" "$package_name" "[disabled]" | tr '[:upper:]' '[:lower:]'
        }
    done
}


case $1 in
    "list")       check_packages; list_packages;;
    "install")    check_packages; install_packages $@;;
    "uninstall")  check_packages; uninstall_packages $@;;
    "disable")    check_packages; disable_packages $@;;
    "enable")     check_packages; enable_packages $@;;
    "upgrade")    check_packages; upgrade_packages $@;;
    "version"|"--version") echo "0.1.0";;
    ""|"--help"|"-h") display_help;;
    *) 
        echo -e "\n - [ERROR] Invalid use of the \`snap\` command -";
        display_help
        exit 1
        ;;
esac
