#!/bin/bash
#
# move - part of the Arch-Setup project
# Copyright (C) 2023, Scott Wyman, development@scottwyman.me
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

#
# move is a simple and reliable way to backup your system
#


DATA_DIRECTORY=$HOME/.config/move
BACKUP_PATHS_FILE=$DATA_DIRECTORY/backup_paths

[[ -d $DATA_DIRECTORY ]] || {
    echo -e "\n - [ERROR] $DATA_DIRECTORY doesn't exist... creating & exiting - \n"
    mkdir -p $DATA_DIRECTORY
    exit 1
}


display_help() {
    echo -e "\nUsage: move [COMMAND]"
    echo -e "\nA script for backing up and moving your important files"

    echo "Commands:"
    printf "\t%-15s %-1s\n" "list" "displays all files & directories to be backed up"
    printf "\t%-15s %-1s\n" "pack" "'packs' all your files into a single directory or compressed file, ready for moving" 
    printf "\t%-15s %-1s\n" "unpack" "'unpacks' all your files and places them around the system" 
    printf "\t%-15s %-1s\n" "version" "Returns version information"

    echo -e "\nCommand Flags:\n"
    echo -e "\tlist:"
    printf "\t    %-20s\t %-1s\n" "-c | --custom-apps" "Display file and directories to be backed up for all supported custom apps"
    printf "\t    %-20s\t %-1s\n" "-a | --all" "Display "
    echo -e "\tpack:"
    printf "\t    %-20s\t %-1s\n" "-c | --compress" "Compress all your files & directories into a single tar file"
    printf "\t    %-20s\t %-1s\n" "-e | --encrypt" "Automatically encrypt the compressed backup file (must also pass the compress flag)"
    printf "\t    %-20s\t %-1s\n" "-C | --clean" "Deletes the original tar file after encryption, keeping only the encrypt tar file (must also pass the compress flag)"
    echo -e "\tunpack:"
    printf "\t    %-20s\t %-1s\n" "-y | --noconfirm" "skip the 'are you sure' prompt"
    printf "\t    %-20s\t %-1s\n" "--undo" "quickly undo the changes made by the last unpack command"
    
    echo -e "\nExamples:"
    echo -e "\t\`move pack\`"

    echo -e "\nError Codes:"
    printf "\t%-3s %-1s\n" "1" "Invalid command"
    printf "\t%-3s %-1s\n" "2" "Package doesn't exist"
    printf "\t%-3s %-1s\n" "3" "Missing dependencies"

    echo ""
}


compress() {
    if [[ -f $BACKUP_PATHS_FILE ]]
    then
        source $BACKUP_PATHS_FILE # imports the 'paths' array

        cp /tmp/example.tar.aes.gz /tmp/example.tar.aes.gz.bak &>/dev/null

        # Verify all paths exist
        for path in ${paths[@]};
        do
            [[ -d $path || -f $path ]] || {
                echo -e "\n - [ERROR] $path from $BACKUP_PATHS_FILE doesn't exist - \n"
                exit 1
            }
        done

        tar -czf /tmp/example.tar ${paths[@]}
    fi
}

encrypt() {
    while :
    do
        openssl enc \
            -a -aes-256-cbc -pbkdf2 --iter 1000000 \
            -in host_backup.tar -out host_backup.tar.aes 2> /dev/null

        # Only exit the loop if the encryption succeeds
        [[ $? == 0 ]] \
            && break \
            || echo -e "\n - Encryption keys don't match... try again - \n"
    done
}

#
# If a supported app is installed, back it up
#
calurse_pack() {
    { which calcurse || type calcurse; } &>/dev/null && {
        [[ -d $HOME/.config/calcurse ]] && {
            echo "under construction"
    }
}

custom_app_pack() {
    calurse_pack
}

pack() {
    # unset flag variables before match, for safety
    local unset skipped_command_input

    #
    # Capture flags
    #
    for arg in "${@}";
    do
        case $arg in
            "--noconfirm" | "-y")
                [[ -n "$noconfirm_flag" ]] && {
                    echo -e "\n - [ERROR] duplicated the 'noconfirm' flag - \n"
                    exit 1
                }
                local noconfirm_flag="--noconfirm"
            ;;
            *) 
                [[ "$arg" == "pack" && -z "$skipped_command_input" ]] && {
                    skipped_command_input=true
                    continue
                }

                local package_names+=($arg)
            ;;
        esac
    done
}




unpack() {
    # unset flag variables before match, for safety
    local unset skipped_command_input

    #
    # Capture flags
    #
    for arg in "${@}";
    do
        case $arg in
            "--noconfirm" | "-y")
                [[ -n "$noconfirm_flag" ]] && {
                    echo -e "\n - [ERROR] duplicated the 'noconfirm' flag - \n"
                    exit 1
                }
                local noconfirm_flag="--noconfirm"
            ;;
            *) 
                [[ "$arg" == "unpack" && -z "$skipped_command_input" ]] && {
                    skipped_command_input=true
                    continue
                }

                local package_names+=($arg)
            ;;
        esac
    done
}

case $1 in
    "pack")          check_packages; pack;;
    "unpack")        check_packages; unpack;;
    "version"|"--version") echo "0.1.0";;
    ""|"--help"|"-h") display_help;;
    *) 
        echo -e "\n - [ERROR] Invalid use of the \`vm\` command -";
        display_help
        exit 1
        ;;
esac
